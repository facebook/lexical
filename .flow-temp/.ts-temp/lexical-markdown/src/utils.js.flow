/**
 * Flowtype definitions for utils
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.20.0
 * @flow
 */

import type { TextNodeWithOffset } from "@lexical/text";
import type {
  DecoratorNode,
  ElementNode,
  LexicalEditor,
  LexicalNode,
  NodeKey,
  TextFormatType,
} from "lexical";
export type AutoFormatTriggerState = $ReadOnly<{|
  anchorOffset: number,
  hasParentNode: boolean,
  isCodeBlock: boolean,
  isParentAListItemNode: boolean,
  isSelectionCollapsed: boolean,
  isSimpleText: boolean,
  nodeKey: NodeKey,
  textContent: string,
|}>;
export type MarkdownFormatKind =
  | "noTransformation"
  | "paragraphH1"
  | "paragraphH2"
  | "paragraphH3"
  | "paragraphH4"
  | "paragraphH5"
  | "paragraphBlockQuote"
  | "paragraphUnorderedList"
  | "paragraphOrderedList"
  | "paragraphCodeBlock"
  | "horizontalRule"
  | "bold"
  | "code"
  | "italic"
  | "underline"
  | "strikethrough"
  | "italic_bold"
  | "strikethrough_italic"
  | "strikethrough_bold"
  | "strikethrough_italic_bold"
  | "link";
export type ScanningContext = {|
  currentElementNode: null | ElementNode,
  editor: LexicalEditor,
  isAutoFormatting: boolean,
  isWithinCodeBlock: boolean,
  joinedText: string | null | void,
  markdownCriteria: MarkdownCriteria,
  patternMatchResults: PatternMatchResults,
  textNodeWithOffset: TextNodeWithOffset | null | void,
  triggerState: AutoFormatTriggerState | null | void,
|};
export type MarkdownCriteria = $ReadOnly<{|
  export?: (
    node: LexicalNode,
    traverseChildren: (node: ElementNode) => string
  ) => string | null,
  exportFormat?: TextFormatType,
  exportTag?: string,
  exportTagClose?: string,
  markdownFormatKind: MarkdownFormatKind | null | void,
  regEx: RegExp,
  regExForAutoFormatting: RegExp,
  requiresParagraphStart: boolean | null | void,
|}>;
declare type CaptureGroupDetail = {|
  offsetInParent: number,
  text: string,
|};
export type PatternMatchResults = {|
  regExCaptureGroups: Array<CaptureGroupDetail>,
|};
export type MarkdownCriteriaWithPatternMatchResults = {|
  markdownCriteria: null | MarkdownCriteria,
  patternMatchResults: null | PatternMatchResults,
|};
export type MarkdownCriteriaArray = Array<MarkdownCriteria>;
export type AutoFormatTriggerKind = "space_trigger" | "codeBlock_trigger";
export type AutoFormatTrigger = {|
  triggerKind: AutoFormatTriggerKind,
  triggerString: string,
|};
declare export var triggers: Array<AutoFormatTrigger>;
declare export var allMarkdownCriteria: MarkdownCriteriaArray;
declare export function getAllTriggers(): Array<AutoFormatTrigger>;
declare export function getAllMarkdownCriteriaForParagraphs(): MarkdownCriteriaArray;
declare export function getAllMarkdownCriteriaForTextNodes(): MarkdownCriteriaArray;
declare export function getAllMarkdownCriteria(): MarkdownCriteriaArray;
declare export function getInitialScanningContext(
  editor: LexicalEditor,
  isAutoFormatting: boolean,
  textNodeWithOffset: null | TextNodeWithOffset,
  triggerState: null | AutoFormatTriggerState
): ScanningContext;
declare export function resetScanningContext(
  scanningContext: ScanningContext
): ScanningContext;
declare export function getCodeBlockCriteria(): MarkdownCriteria;
declare export function getPatternMatchResultsForCriteria(
  markdownCriteria: MarkdownCriteria,
  scanningContext: ScanningContext,
  parentElementNode: ElementNode
): null | PatternMatchResults;
declare export function getPatternMatchResultsForCodeBlock(
  scanningContext: ScanningContext,
  text: string
): null | PatternMatchResults;
declare export function hasPatternMatchResults(
  scanningContext: ScanningContext
): boolean;
declare export function getTextNodeWithOffsetOrThrow(
  scanningContext: ScanningContext
): TextNodeWithOffset;
declare export function transformTextNodeForMarkdownCriteria<T>(
  scanningContext: ScanningContext,
  elementNode: ElementNode,
  createHorizontalRuleNode: null | (() => DecoratorNode<T>)
): void;
declare export function getParentElementNodeOrThrow(
  scanningContext: ScanningContext
): ElementNode;
