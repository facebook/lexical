/**
 * Flowtype definitions for LexicalElementNode
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.20.0
 * @flow
 */

import type { NodeKey, SerializedLexicalNode } from "../LexicalNode";
import type {
  GridSelection,
  NodeSelection,
  RangeSelection,
} from "../LexicalSelection";
import type { Spread } from "lexical";
import { TextNode } from "../";
import { LexicalNode } from "../LexicalNode";
export type SerializedElementNode = Spread<
  {|
    children: Array<SerializedLexicalNode>,
    direction: "ltr" | "rtl" | null,
    format: ElementFormatType,
    indent: number,
  |},
  SerializedLexicalNode
>;
export type ElementFormatType = "left" | "center" | "right" | "justify" | "";
declare export class ElementNode mixins LexicalNode {
  __children: Array<NodeKey>;
  __format: number;
  __indent: number;
  __dir: "ltr" | "rtl" | null;
  constructor(key?: NodeKey): this;
  getFormat(): number;
  getFormatType(): ElementFormatType;
  getIndent(): number;
  getChildren<T: LexicalNode>(): Array<T>;
  getChildrenKeys(): Array<NodeKey>;
  getChildrenSize(): number;
  isEmpty(): boolean;
  isDirty(): boolean;
  isLastChild(): boolean;
  getAllTextNodes(includeInert?: boolean): Array<TextNode>;
  getFirstDescendant<T: LexicalNode>(): null | T;
  getLastDescendant<T: LexicalNode>(): null | T;
  getDescendantByIndex<T: LexicalNode>(index: number): null | T;
  getFirstChild<T: LexicalNode>(): null | T;
  getFirstChildOrThrow<T: LexicalNode>(): T;
  getLastChild<T: LexicalNode>(): null | T;
  getChildAtIndex<T: LexicalNode>(index: number): null | T;
  getTextContent(includeInert?: boolean, includeDirectionless?: false): string;
  getDirection(): "ltr" | "rtl" | null;
  hasFormat(type: ElementFormatType): boolean;
  select(_anchorOffset?: number, _focusOffset?: number): RangeSelection;
  selectStart(): RangeSelection;
  selectEnd(): RangeSelection;
  clear(): this;
  append(...nodesToAppend: LexicalNode[]): this;
  setDirection(direction: "ltr" | "rtl" | null): this;
  setFormat(type: ElementFormatType): this;
  setIndent(indentLevel: number): this;
  splice(
    start: number,
    deleteCount: number,
    nodesToInsert: Array<LexicalNode>
  ): this;
  exportJSON(): SerializedElementNode;
  insertNewAfter(selection: RangeSelection): null | LexicalNode;
  canInsertTab(): boolean;
  canIndent(): boolean;
  collapseAtStart(selection: RangeSelection): boolean;
  excludeFromCopy(destination?: "clone" | "html"): boolean;
  canExtractContents(): boolean;
  canReplaceWith(replacement: LexicalNode): boolean;
  canInsertAfter(node: LexicalNode): boolean;
  canBeEmpty(): boolean;
  canInsertTextBefore(): boolean;
  canInsertTextAfter(): boolean;
  isInline(): boolean;
  canMergeWith(node: ElementNode): boolean;
  extractWithChild(
    child: LexicalNode,
    selection: RangeSelection | NodeSelection | GridSelection,
    destination: "clone" | "html"
  ): boolean;
}
declare export function $isElementNode(
  node: LexicalNode | null | void
): boolean;
