/**
 * Flowtype definitions for LexicalSelection
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.20.0
 * @flow
 */

import type { LexicalEditor } from "./LexicalEditor";
import type { EditorState } from "./LexicalEditorState";
import type { LexicalNode, NodeKey } from "./LexicalNode";
import type { ElementNode } from "./nodes/LexicalElementNode";
import type { TextFormatType } from "./nodes/LexicalTextNode";
import { TextNode } from ".";
export type TextPointType = {|
  _selection: RangeSelection | GridSelection,
  getNode: () => TextNode,
  is: (PointType: any) => boolean,
  isAtNodeEnd: () => boolean,
  isBefore: (PointType: any) => boolean,
  key: NodeKey,
  offset: number,
  set: (key: NodeKey, offset: number, type: "text" | "element") => void,
  type: "text",
|};
export type ElementPointType = {|
  _selection: RangeSelection | GridSelection,
  getNode: () => ElementNode,
  is: (PointType: any) => boolean,
  isAtNodeEnd: () => boolean,
  isBefore: (PointType: any) => boolean,
  key: NodeKey,
  offset: number,
  set: (key: NodeKey, offset: number, type: "text" | "element") => void,
  type: "element",
|};
export type PointType = TextPointType | ElementPointType;
declare export class Point {
  key: NodeKey;
  offset: number;
  type: "text" | "element";
  _selection: RangeSelection | GridSelection;
  constructor(key: NodeKey, offset: number, type: "text" | "element"): this;
  is(point: PointType): boolean;
  isBefore(b: PointType): boolean;
  getNode(): LexicalNode;
  set(key: NodeKey, offset: number, type: "text" | "element"): void;
}
declare export function $moveSelectionPointToEnd(
  point: PointType,
  node: LexicalNode
): void;
declare interface BaseSelection {
  clone(): BaseSelection;
  dirty: boolean;
  extract(): Array<LexicalNode>;
  getNodes(): Array<LexicalNode>;
  getTextContent(): string;
  insertRawText(text: string): void;
  is(selection: null | RangeSelection | NodeSelection | GridSelection): boolean;
}
declare export class NodeSelection implements BaseSelection {
  _nodes: Set<NodeKey>;
  dirty: boolean;
  _cachedNodes: null | Array<LexicalNode>;
  constructor(objects: Set<NodeKey>): this;
  is(selection: null | RangeSelection | NodeSelection | GridSelection): boolean;
  add(key: NodeKey): void;
  delete(key: NodeKey): void;
  clear(): void;
  has(key: NodeKey): boolean;
  clone(): NodeSelection;
  extract(): Array<LexicalNode>;
  insertRawText(text: string): void;
  insertText(): void;
  getNodes(): Array<LexicalNode>;
  getTextContent(): string;
}
declare export function $isRangeSelection(x: mixed): boolean;
export type GridSelectionShape = {|
  fromX: number,
  fromY: number,
  toX: number,
  toY: number,
|};
declare export class GridSelection implements BaseSelection {
  gridKey: NodeKey;
  anchor: PointType;
  focus: PointType;
  dirty: boolean;
  _cachedNodes: Array<LexicalNode>;
  constructor(gridKey: NodeKey, anchor: PointType, focus: PointType): this;
  is(selection: null | RangeSelection | NodeSelection | GridSelection): boolean;
  set(gridKey: NodeKey, anchorCellKey: NodeKey, focusCellKey: NodeKey): void;
  clone(): GridSelection;
  isCollapsed(): boolean;
  isBackward(): boolean;
  getCharacterOffsets(): [number, number];
  extract(): Array<LexicalNode>;
  insertRawText(text: string): void;
  insertText(): void;
  getShape(): GridSelectionShape;
  getNodes(): Array<LexicalNode>;
  getTextContent(): string;
}
declare export function $isGridSelection(x: mixed): boolean;
declare export class RangeSelection implements BaseSelection {
  anchor: PointType;
  focus: PointType;
  dirty: boolean;
  format: number;
  _cachedNodes: null | Array<LexicalNode>;
  constructor(anchor: PointType, focus: PointType, format: number): this;
  is(selection: null | RangeSelection | NodeSelection | GridSelection): boolean;
  isBackward(): boolean;
  isCollapsed(): boolean;
  getNodes(): Array<LexicalNode>;
  setTextNodeRange(
    anchorNode: TextNode,
    anchorOffset: number,
    focusNode: TextNode,
    focusOffset: number
  ): void;
  getTextContent(): string;
  applyDOMRange(range: StaticRange): void;
  clone(): RangeSelection;
  toggleFormat(format: TextFormatType): void;
  hasFormat(type: TextFormatType): boolean;
  insertRawText(text: string): void;
  insertText(text: string): void;
  removeText(): void;
  formatText(formatType: TextFormatType): void;
  insertNodes(nodes: Array<LexicalNode>, selectStart?: boolean): boolean;
  insertParagraph(): void;
  insertLineBreak(selectStart?: boolean): void;
  getCharacterOffsets(): [number, number];
  extract(): Array<LexicalNode>;
  modify(
    alter: "move" | "extend",
    isBackward: boolean,
    granularity: "character" | "word" | "lineboundary"
  ): void;
  deleteCharacter(isBackward: boolean): void;
  deleteLine(isBackward: boolean): void;
  deleteWord(isBackward: boolean): void;
}
declare export function $isNodeSelection(x: mixed): boolean;
declare export function internalMakeRangeSelection(
  anchorKey: NodeKey,
  anchorOffset: number,
  focusKey: NodeKey,
  focusOffset: number,
  anchorType: "text" | "element",
  focusType: "text" | "element"
): RangeSelection;
declare export function $createRangeSelection(): RangeSelection;
declare export function $createNodeSelection(): NodeSelection;
declare export function $createGridSelection(): GridSelection;
declare export function internalCreateSelection(
  editor: LexicalEditor
): null | RangeSelection | NodeSelection | GridSelection;
declare export function internalCreateRangeSelection(
  lastSelection: null | RangeSelection | NodeSelection | GridSelection,
  domSelection: Selection | null,
  editor: LexicalEditor
): null | RangeSelection;
declare export function $getSelection():
  | null
  | RangeSelection
  | NodeSelection
  | GridSelection;
declare export function $getPreviousSelection():
  | null
  | RangeSelection
  | NodeSelection
  | GridSelection;
declare export function $updateElementSelectionOnCreateDeleteNode(
  selection: RangeSelection,
  parentNode: LexicalNode,
  nodeOffset: number,
  times?: number
): void;
declare export function applySelectionTransforms(
  nextEditorState: EditorState,
  editor: LexicalEditor
): void;
declare export function moveSelectionPointToSibling(
  point: PointType,
  node: LexicalNode,
  parent: ElementNode,
  prevSibling: LexicalNode | null,
  nextSibling: LexicalNode | null
): void;
declare export function adjustPointOffsetForMergedSibling(
  point: PointType,
  isBefore: boolean,
  key: NodeKey,
  target: TextNode,
  textLength: number
): void;
declare export function updateDOMSelection(
  prevSelection: RangeSelection | NodeSelection | GridSelection | null,
  nextSelection: RangeSelection | NodeSelection | GridSelection | null,
  editor: LexicalEditor,
  domSelection: Selection,
  tags: Set<string>,
  rootElement: HTMLElement
): void;
