/**
 * Flowtype definitions for LexicalEditor
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.20.0
 * @flow
 */

import type { EditorState, SerializedEditorState } from "./LexicalEditorState";
import type { DOMConversion, LexicalNode, NodeKey } from "./LexicalNode";
import { Class } from "utility-types";
export type Spread<T1, T2> = {|
  ...$ObjMapi<
    { [k: Exclude<$Keys<T1>, $Keys<T2>>]: any },
    <K>(K) => $ElementType<T1, K>
  >,
  ...T2,
|};
export type EditorThemeClassName = string;
export type TextNodeThemeClasses = {|
  base?: EditorThemeClassName,
  bold?: EditorThemeClassName,
  code?: EditorThemeClassName,
  italic?: EditorThemeClassName,
  strikethrough?: EditorThemeClassName,
  underline?: EditorThemeClassName,
  underlineStrikethrough?: EditorThemeClassName,
|};
export type EditorUpdateOptions = {|
  onUpdate?: () => void,
  skipTransforms?: true,
  tag?: string,
|};
export type EditorSetOptions = {|
  tag?: string,
|};
export type EditorThemeClasses = {|
  code?: EditorThemeClassName,
  codeHighlight?: { [key: string]: EditorThemeClassName },
  hashtag?: EditorThemeClassName,
  heading?: {|
    h1?: EditorThemeClassName,
    h2?: EditorThemeClassName,
    h3?: EditorThemeClassName,
    h4?: EditorThemeClassName,
    h5?: EditorThemeClassName,
  |},
  image?: EditorThemeClassName,
  link?: EditorThemeClassName,
  list?: {|
    ul?: EditorThemeClassName,
    ulDepth?: Array<EditorThemeClassName>,
    ol?: EditorThemeClassName,
    olDepth?: Array<EditorThemeClassName>,
    listitem?: EditorThemeClassName,
    listitemChecked?: EditorThemeClassName,
    listitemUnchecked?: EditorThemeClassName,
    nested?: {|
      list?: EditorThemeClassName,
      listitem?: EditorThemeClassName,
    |},
  |},
  ltr?: EditorThemeClassName,
  mark?: EditorThemeClassName,
  markOverlap?: EditorThemeClassName,
  paragraph?: EditorThemeClassName,
  quote?: EditorThemeClassName,
  root?: EditorThemeClassName,
  rtl?: EditorThemeClassName,
  table?: EditorThemeClassName,
  tableCell?: EditorThemeClassName,
  tableCellHeader?: EditorThemeClassName,
  tableRow?: EditorThemeClassName,
  text?: TextNodeThemeClasses,
  [key: string]:
    | EditorThemeClassName
    | TextNodeThemeClasses
    | {|
        [key: string]:
          | Array<EditorThemeClassName>
          | EditorThemeClassName
          | TextNodeThemeClasses
          | {|
              [key: string]: EditorThemeClassName,
            |},
      |},
|};
export type EditorConfig = {|
  disableEvents?: boolean,
  theme: EditorThemeClasses,
|};
export type RegisteredNodes = Map<string, RegisteredNode>;
export type RegisteredNode = {|
  klass: Class<LexicalNode>,
  transforms: Set<Transform<LexicalNode>>,
|};
export type Transform<T> = (node: T) => void;
export type ErrorHandler = (error: Error) => void;
export type MutationListeners = Map<MutationListener, Class<LexicalNode>>;
export type MutatedNodes = Map<Class<LexicalNode>, Map<NodeKey, NodeMutation>>;
export type NodeMutation = "created" | "updated" | "destroyed";
export type UpdateListener = (arg0: {|
  dirtyElements: Map<NodeKey, IntentionallyMarkedAsDirtyElement>,
  dirtyLeaves: Set<NodeKey>,
  editorState: EditorState,
  normalizedNodes: Set<NodeKey>,
  prevEditorState: EditorState,
  tags: Set<string>,
|}) => void;
export type DecoratorListener<T = mixed> = (decorator: {
  [key: NodeKey]: T,
}) => void;
export type RootListener = (
  rootElement: null | HTMLElement,
  prevRootElement: null | HTMLElement
) => void;
export type TextContentListener = (text: string) => void;
export type MutationListener = (nodes: Map<NodeKey, NodeMutation>) => void;
export type CommandListener<P> = (payload: P, editor: LexicalEditor) => boolean;
export type ReadOnlyListener = (readOnly: boolean) => void;
export type CommandListenerPriority = 0 | 1 | 2 | 3 | 4;
declare export var COMMAND_PRIORITY_EDITOR: 0;
declare export var COMMAND_PRIORITY_LOW: 1;
declare export var COMMAND_PRIORITY_NORMAL: 2;
declare export var COMMAND_PRIORITY_HIGH: 3;
declare export var COMMAND_PRIORITY_CRITICAL: 4;
export type LexicalCommand<T> = $ReadOnly<{ [key: string]: mixed }>;
declare type Commands = Map<
  LexicalCommand<mixed>,
  Array<Set<CommandListener<mixed>>>
>;
declare type Listeners = {|
  decorator: Set<DecoratorListener<>>,
  mutation: MutationListeners,
  readonly: Set<ReadOnlyListener>,
  root: Set<RootListener>,
  textcontent: Set<TextContentListener>,
  update: Set<UpdateListener>,
|};
export type Listener =
  | DecoratorListener<>
  | ReadOnlyListener
  | MutationListener
  | RootListener
  | TextContentListener
  | UpdateListener;
export type ListenerType =
  | "update"
  | "root"
  | "decorator"
  | "textcontent"
  | "mutation"
  | "readonly";
export type TransformerType = "text" | "decorator" | "element" | "root";
export type IntentionallyMarkedAsDirtyElement = boolean;
declare type DOMConversionCache = Map<
  string,
  Array<(node: Node) => DOMConversion | null>
>;
declare export function resetEditor(
  editor: LexicalEditor,
  prevRootElement: null | HTMLElement,
  nextRootElement: null | HTMLElement,
  pendingEditorState: EditorState
): void;
declare export function createEditor(editorConfig?: {|
  disableEvents?: boolean,
  editorState?: EditorState,
  nodes?: $ReadOnlyArray<Class<LexicalNode>>,
  onError?: ErrorHandler,
  parentEditor?: LexicalEditor,
  readOnly?: boolean,
  theme?: EditorThemeClasses,
|}): LexicalEditor;
declare export class LexicalEditor {
  _headless: boolean;
  _parentEditor: null | LexicalEditor;
  _rootElement: null | HTMLElement;
  _editorState: EditorState;
  _pendingEditorState: null | EditorState;
  _compositionKey: null | NodeKey;
  _deferred: Array<() => void>;
  _keyToDOMMap: Map<NodeKey, HTMLElement>;
  _updates: Array<[() => void, EditorUpdateOptions]>;
  _updating: boolean;
  _listeners: Listeners;
  _commands: Commands;
  _nodes: RegisteredNodes;
  _decorators: { [key: NodeKey]: mixed };
  _pendingDecorators: null | { [key: NodeKey]: mixed };
  _config: EditorConfig;
  _dirtyType: 0 | 1 | 2;
  _cloneNotNeeded: Set<NodeKey>;
  _dirtyLeaves: Set<NodeKey>;
  _dirtyElements: Map<NodeKey, IntentionallyMarkedAsDirtyElement>;
  _normalizedNodes: Set<NodeKey>;
  _updateTags: Set<string>;
  _observer: null | MutationObserver;
  _key: string;
  _onError: ErrorHandler;
  _htmlConversions: DOMConversionCache;
  _readOnly: boolean;
  constructor(
    editorState: EditorState,
    parentEditor: null | LexicalEditor,
    nodes: RegisteredNodes,
    config: EditorConfig,
    onError: ErrorHandler,
    htmlConversions: DOMConversionCache,
    readOnly: boolean
  ): this;
  isComposing(): boolean;
  registerUpdateListener(listener: UpdateListener): () => void;
  registerReadOnlyListener(listener: ReadOnlyListener): () => void;
  registerDecoratorListener<T>(listener: DecoratorListener<T>): () => void;
  registerTextContentListener(listener: TextContentListener): () => void;
  registerRootListener(listener: RootListener): () => void;
  registerCommand<P>(
    command: LexicalCommand<P>,
    listener: CommandListener<P>,
    priority: CommandListenerPriority
  ): () => void;
  registerMutationListener(
    klass: Class<LexicalNode>,
    listener: MutationListener
  ): () => void;
  registerNodeTransform<T: LexicalNode>(
    klass: Class<T>,
    listener: Transform<T>
  ): () => void;
  hasNodes(nodes: Array<Class<LexicalNode>>): boolean;
  dispatchCommand<P>(type: LexicalCommand<P>, payload: P): boolean;
  getDecorators<T>(): { [key: NodeKey]: T };
  getRootElement(): null | HTMLElement;
  getKey(): string;
  setRootElement(nextRootElement: null | HTMLElement): void;
  getElementByKey(key: NodeKey): HTMLElement | null;
  getEditorState(): EditorState;
  setEditorState(editorState: EditorState, options?: EditorSetOptions): void;
  parseEditorState(
    maybeStringifiedEditorState: string | SerializedEditorState,
    updateFn?: () => void
  ): EditorState;
  update(updateFn: () => void, options?: EditorUpdateOptions): void;
  focus(callbackFn?: () => void): void;
  blur(): void;
  isReadOnly(): boolean;
  setReadOnly(readOnly: boolean): void;
  toJSON(): {|
    editorState: EditorState,
  |};
}
