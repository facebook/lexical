/**
 * Flowtype definitions for LexicalNode
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.20.0
 * @flow
 */

import type { EditorConfig, LexicalEditor } from "./LexicalEditor";
import type { RangeSelection } from "./LexicalSelection";
import { ElementNode } from ".";
export type NodeMap = Map<NodeKey, LexicalNode>;
export type SerializedLexicalNode = {|
  type: string,
  version: number,
|};
declare export function removeNode(
  nodeToRemove: LexicalNode,
  restoreSelection: boolean,
  preserveEmptyParent?: boolean
): void;
declare export function $getNodeByKeyOrThrow<N: LexicalNode>(key: NodeKey): N;
export type DOMConversion = {|
  conversion: DOMConversionFn,
  priority: 0 | 1 | 2 | 3 | 4,
|};
export type DOMConversionFn = (
  element: Node,
  parent?: Node
) => DOMConversionOutput;
export type DOMChildConversion = (
  lexicalNode: LexicalNode,
  parentLexicalNode: LexicalNode | null
) => LexicalNode | null | void;
export type DOMConversionMap = {
  [key: NodeName]: (node: Node) => DOMConversion | null,
};
declare type NodeName = string;
export type DOMConversionOutput = {|
  after?: (childLexicalNodes: Array<LexicalNode>) => Array<LexicalNode>,
  forChild?: DOMChildConversion,
  node: LexicalNode | null,
|};
export type DOMExportOutput = {|
  after?: (
    generatedElement: HTMLElement | null | void
  ) => HTMLElement | null | void,
  element: HTMLElement | null,
|};
export type NodeKey = string;
declare export class LexicalNode {
  [x: string]: any;
  __type: string;
  __key: NodeKey;
  __parent: null | NodeKey;
  static getType(): string;
  static clone(_data: mixed): LexicalNode;
  constructor(key?: NodeKey): this;
  getType(): string;
  isAttached(): boolean;
  isSelected(): boolean;
  getKey(): NodeKey;
  getIndexWithinParent(): number;
  getParent<T: ElementNode>(): T | null;
  getParentOrThrow<T: ElementNode>(): T;
  getTopLevelElement(): ElementNode | this | null;
  getTopLevelElementOrThrow(): ElementNode | this;
  getParents<T: ElementNode>(): Array<T>;
  getParentKeys(): Array<NodeKey>;
  getPreviousSibling<T: LexicalNode>(): T | null;
  getPreviousSiblings<T: LexicalNode>(): Array<T>;
  getNextSibling<T: LexicalNode>(): T | null;
  getNextSiblings<T: LexicalNode>(): Array<T>;
  getCommonAncestor<T: ElementNode>(node: LexicalNode): T | null;
  is(object: LexicalNode | null | void): boolean;
  isBefore(targetNode: LexicalNode): boolean;
  isParentOf(targetNode: LexicalNode): boolean;
  getNodesBetween(targetNode: LexicalNode): Array<LexicalNode>;
  isDirty(): boolean;
  getLatest(): this;
  getWritable(): this;
  getTextContent(
    _includeInert?: boolean,
    _includeDirectionless?: false
  ): string;
  getTextContentSize(
    includeInert?: boolean,
    includeDirectionless?: false
  ): number;
  createDOM(_config: EditorConfig, _editor: LexicalEditor): HTMLElement;
  updateDOM(
    _prevNode: mixed,
    _dom: HTMLElement,
    _config: EditorConfig
  ): boolean;
  exportDOM(editor: LexicalEditor): DOMExportOutput;
  static importDOM(): DOMConversionMap | null;
  exportJSON(): SerializedLexicalNode;
  static importJSON(_serializedNode: SerializedLexicalNode): LexicalNode;
  remove(preserveEmptyParent?: boolean): void;
  replace<N: LexicalNode>(replaceWith: N): N;
  insertAfter(nodeToInsert: LexicalNode): LexicalNode;
  insertBefore(nodeToInsert: LexicalNode): LexicalNode;
  selectPrevious(anchorOffset?: number, focusOffset?: number): RangeSelection;
  selectNext(anchorOffset?: number, focusOffset?: number): RangeSelection;
  markDirty(): void;
}
